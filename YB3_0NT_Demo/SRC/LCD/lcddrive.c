/****************************************************************************************
* 文件名：LCDDRIVE.C
* 功能：图形液晶240*128驱动(型号为SMG240128A)。32K显示存，0000H-7FFFH地址。显示是横向字节，高位
*      在前。
* 说明：图形液晶采用T6963C为LCD控制芯片，内带负压产生器，单5伏供电，并行接口(使用LPC2210驱动)。
* 硬件连接： D0--D7  <===>  D0--D7
*           /WR     <===>  nWE
*           /RD     <===>  nOE
*           /CE     <===>  nCS3_1
*           C/D     <===>  A1
*
*           /RST    <===>  VCC
****************************************************************************************/
#define	__LCDDRIVE_C
#include "LCDconfig.h"

TCOLOR  	gui_disp_buf[GUI_LCM_YMAX][GUI_LCM_XMAX/8];				// 声明GUI显示缓冲区  

/* 定义LCM地址 */
//#define  TG240128_COM    	(*((volatile unsigned short *) 0x83000002))
//#define  TG240128_DAT    	(*((volatile unsigned short *) 0x83000000))

#define  TG240128_COM    	(*((volatile unsigned short *) 0xE2000002))
#define  TG240128_DAT    	(*((volatile unsigned short *) 0xE2000000))


	
/***********************************************************************		  
* 名称：LCD_WriteCommand()
* 功能：写命令子程序。(发送命令前，不检查液晶模块的状态)
* 入口参数：command  	要写入LCM的命令字
* 出口参数：无
* 说明：函数会设置LCM数据总线为输出方式
***********************************************************************/	         	  
#define   LCD_WriteCommand(command)  TG240128_COM = (uint16)command


/***********************************************************************		  
* 名称：LCD_WriteData()
* 功能：写数据子程序。(发送数据前，不检查液晶模块的状态)
* 入口参数：dat  	要写入LCM的数据
* 出口参数：无
* 说明：函数会设置LCM数据总线为输出方式
***********************************************************************/		  
#define  LCD_WriteData(dat)  TG240128_DAT = (uint16)dat



/***********************************************************************		  
* 名称：LCD_ReadState()
* 功能：读取状态字子程序。
* 入口参数：无
* 出口参数：返回值即为读出的状态字
* 说明：函数会设置LCM数据总线为输入方式
***********************************************************************/
#define  LCD_ReadState()	TG240128_COM


/***********************************************************************		  
* 名称：LCD_ReadData()
* 功能：读取数据子程序。
* 入口参数：无
* 出口参数：返回值即为读出的数据
* 说明：函数会设置LCM数据总线为输入方式
***********************************************************************/		   
#define  LCD_ReadData()		TG240128_DAT


/* 以下为LCM的驱动层，主要负责发送T6963的各种命令，提供设置显示地址等功能，在发送命令前会检测其状态字。带参数命令模式：先参数，后命令；操作模式：先命令，后数据 */

/* T6963C 命令定义 */
#define  LCD_CUR_POS		0x21						/* 光标位置设置(只有设置到有效显示地址并打开显示时才看到) */
#define  LCD_CGR_POS		0x22						/* CGRAM偏置地址设置(可以增加自已的符号) */
#define  LCD_ADR_POS		0x24						/* 地址指针位置(设置读写操作指针) */

#define  LCD_TXT_STP		0x40						/* 文本区首址(从此地址开始向屏幕左上角显示字符) */
#define  LCD_TXT_WID		0x41						/* 文本区宽度(设置显示宽度，N/6或N/8，其中N为x轴的点数) */
#define  LCD_GRH_STP		0x42						/* 图形区首址(从此地址开始向屏幕左上角显示点) */
#define  LCD_GRH_WID		0x43						/* 图形区宽度(设置显示宽度，N/6或N/8，其中N为x轴的点数) */

#define  LCD_MOD_OR			0x80						/* 显示方式：逻辑或 */
#define  LCD_MOD_XOR		0x81						/* 显示方式：逻辑异或 */
#define  LCD_MOD_AND		0x82						/* 显示方式：逻辑与 */
#define  LCD_MOD_TCH		0x83						/* 显示方式：文本特征 */

#define  LCD_DIS_SW			0x90						/* 显示开关：D0=1/0，光标闪烁启用/禁用 */
														/* 			D1=1/0，光标显示启用/禁用 */
														/* 			D2=1/0，文本显示启用/禁用(打开后再使用) */
														/* 			D3=1/0，图形显示启用/禁用(打开后再使用) */
														
#define  LCD_CUR_SHP		0xA0						/* 光标形状选择：0xA0-0xA7表示光标占的行数 */

#define  LCD_AUT_WR			0xB0						/* 自动写设置 */
#define  LCD_AUT_RD			0xB1						/* 自动读设置 */
#define  LCD_AUT_OVR		0xB2						/* 自动读/写结束 */

#define  LCD_INC_WR			0xC0						/* 数据一次写，地址加1 */
#define  LCD_INC_RD			0xC1						/* 数据一次读，地址加1 */
#define  LCD_DEC_WR			0xC2						/* 数据一次写，地址减1 */
#define  LCD_DEC_RD			0xC3						/* 数据一次读，地址减1 */
#define  LCD_NOC_WR			0xC4						/* 数据一次写，地址不变 */
#define  LCD_NOC_RD			0xC5						/* 数据一次读，地址不变 */

#define  LCD_SCN_RD			0xE0						/* 屏读 */

#define  LCD_SCN_CP			0xE8						/* 屏拷贝 */

#define  LCD_BIT_OP			0xF0						/* 位操作：D0-D2--定义D0-D7位，D3--1为置位，0为清除 */


/***********************************************************************
* 名称：LCD_TestStaBit01()
* 功能：判断读写指令和读写数据是否允许。
* 入口参数：无
* 出口参数：返回0表示禁止，否则表示允许
***********************************************************************/
uint8  LCD_TestStaBit01(void)
{  
	uint8 i,j;

	for(i=100; i>0; i--)
	{  
		j	= LCD_ReadState();
		if ( (j&0x03)==0x03 )
		break;
	}
	return(i);
}


/***********************************************************************
* 名称：LCD_TestStaBit3()
* 功能：数据自动写状态是否允许。
* 入口参数：无
* 出口参数：返回0表示禁止，否则表示允许
***********************************************************************/
uint8  LCD_TestStaBit3(void)
{  
	uint8 i,j;
	
	for(i=100; i>0; i--)
	{
		j	= LCD_ReadState();
		if( (j&0x08)==0x08 ) 
			break;
	}
	return(i);
}


/***********************************************************************
* 名称：LCD_WriteTCommand1()
* 功能：写无参数命令子程序。会先判断LCM状态字。
* 入口参数：command  		要写入LCM的命令字
* 出口参数：操作出错返回0，否则返回1
***********************************************************************/
uint8  LCD_WriteTCommand1(uint8 command)
{  
	if( LCD_TestStaBit01()==0 ) 
		return(0);
	
	LCD_WriteCommand(command);		// 发送命令字

	return(1);
}


/***********************************************************************
* 名称：LCD_WriteTCommand3()
* 功能：写双参数命令子程序。会先判断LCM状态字。
* 入口参数：command  	要写入LCM的命令字
*          dat1		参数1
*          dat2		参数2
* 出口参数：操作出错返回0，否则返回1
* 说明：先发送两字节参数据数据，再发送命令字
***********************************************************************/
uint8  LCD_WriteTCommand3(uint8 command, uint8 dat1, uint8 dat2)
{  if( LCD_TestStaBit01()==0 ) return(0);
   LCD_WriteData(dat1);				// 发送数据1
   
   if( LCD_TestStaBit01()==0 ) return(0);
   LCD_WriteData(dat2);				// 发送数据2
   
   if( LCD_TestStaBit01()==0 ) return(0);
   LCD_WriteCommand(command);		// 发送命令字
   
   return(1);
}


/***********************************************************************
* 名称：LCD_WriteTCommand2()
* 功能：写单参数命令子程序。会先判断LCM状态字。
* 入口参数：command  	要写入LCM的命令字
*          dat1		参数1
* 出口参数：操作出错返回0，否则返回1
* 说明：先发送参数据数据，再发送命令字
***********************************************************************/
uint8  LCD_WriteTCommand2(uint8 command, uint8 dat1)
{  if( LCD_TestStaBit01()==0 ) return(0);
   LCD_WriteData(dat1);				// 发送数据1
   
   if( LCD_TestStaBit01()==0 ) return(0);
   LCD_WriteCommand(command);		// 发送命令字
   
   return(1);
}


/***********************************************************************
* 名称：LCD_WriteTData1()
* 功能：写1字节数据子程序。会先判断状态字。
* 入口参数：dat  		要写入LCM的数据
* 出口参数：操作出错返回0，否则返回1
***********************************************************************/
uint8  LCD_WriteTData1(uint8 dat)
{  

   if( LCD_TestStaBit3()==0 ) return(0);
   LCD_WriteData(dat);				// 发送命令字
   
   return(1);
}


/* 以下为LCM的用户接口层，主要负责解释用户命令，并发送到LCM，为用户编程提供接口 */


/***********************************************************************
* 名称：LCD_Initialize()
* 功能：LCM初始化，将LCM初始化为纯图形模式，显示起始地址为0x0000，。
* 入口参数：无
* 出口参数：无
* 说明：函数会设置LCM数据总线为输出方式
***********************************************************************/
void  LCD_Initialize(void)
{  
   LCD_WriteTCommand3(LCD_TXT_STP, 0x00, 0x00);			// 设置文本方式RAM起始地址
   LCD_WriteTCommand3(LCD_TXT_WID, 30, 0x00);			// 设置文本模式的宽度，宽度为N/6或N/8，N为宽度点数，如240
   LCD_WriteTCommand3(LCD_GRH_STP, 0x00, 0x00);			// 设置图形方式RAM起始地址
   LCD_WriteTCommand3(LCD_GRH_WID, 30, 0x00);			// 设置图形模式的宽度，宽度为N/6或N/8，N为宽度点数，如240
   LCD_WriteTCommand1(LCD_MOD_OR);						// 设置显示方式为"或"
   LCD_WriteTCommand1(LCD_DIS_SW|0x08);					// 设置纯图形显示模式
}


/***********************************************************************
* 名称：LCD_FillAll()
* 功能：LCD填充。以图形方式进行填充，起始地址为0x0000。
* 入口参数：dat		要填充的数据
* 出口参数：无
***********************************************************************/
void  LCD_FillAll(uint8 dat)
{  uint32  i;

   LCD_WriteTCommand3(LCD_ADR_POS, 0x00, 0x00);			// 置地址指针
   LCD_WriteTCommand1(LCD_AUT_WR);						// 自动写
   for(i=0;i<128*30;i++)
   {  
   		T0TCR = 0x00; 
   		LCD_WriteTData1(dat);							// 写数据
		T0TCR = 0x01; 
   }
   LCD_WriteTCommand1(LCD_AUT_OVR);						// 自动写结束
   LCD_WriteTCommand3(LCD_ADR_POS,0x00,0x00);			// 重置地址指针
}


/****************************************************************************
* 名称：LCD_UpdatePoint()
* 功能：在指定位置上画点，刷新某一点。
* 入口参数： x		指定点所在列的位置
*           y		指定点所在行的位置
* 出口参数：返回值为1时表示操作成功，为0时表示操作失败。
* 说明：操作失败原因是指定地址超出缓冲区范围。
****************************************************************************/
void  LCD_UpdatePoint(uint32 x, uint32 y)
{  uint32  addr; 
 
   /* 找出目标地址 */
   addr = y*(GUI_LCM_XMAX>>3) + (x>>3);
   LCD_WriteTCommand3(LCD_ADR_POS, addr&0xFF, addr>>8);	// 置地址指针
   
   /* 输出数据 */
   LCD_WriteTCommand2(LCD_INC_WR, gui_disp_buf[y][x>>3]);
}



/****************************************************************************
*                    与LCM相关的GUI接口函数
****************************************************************************/


/****************************************************************************
* 名称：GUI_FillSCR()
* 功能：全屏填充。直接使用数据填充显示缓冲区。
* 入口参数：dat		填充的数据(对于黑白色LCM，为0的点灭，为1的点显示)
* 出口参数：无
****************************************************************************/
void  GUI_FillSCR(uint8 dat)
{  uint32  i, j;

   for(i=0; i<GUI_LCM_YMAX; i++)		// 历遍所有行
   {  for(j=0; j<GUI_LCM_XMAX/8; j++)	// 历遍所有行
      {  gui_disp_buf[i][j] = dat;		// 填充数据
	  }
   }
   
   /* 填充LCM */
    LCD_FillAll(dat);
}


/****************************************************************************
* 名称：GUI_Initialize()
* 功能：初始化GUI，包括初始化显示缓冲区，初始化LCM并清屏。
* 入口参数：无
* 出口参数：无
****************************************************************************/
void  GUI_Initialize(void)
{  
   LCD_Initialize();					// 初始化LCM模块工作模式，纯图形模式
   GUI_FillSCR(0x00);					// 初始化缓冲区为0x00，并输出屏幕(清屏)
} 


/****************************************************************************
* 名称：GUI_ClearSCR()
* 功能：清屏。
* 入口参数：无
* 出口参数：无
* 说明：用户根据LCM的实际情况编写此函数。
****************************************************************************/
void  GUI_ClearSCR(void)
{  
	GUI_FillSCR(0x00);
	g_u8PosX=0;
	g_u8PosY=0;
}


uint8 const  DCB_HEX_TAB[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};

/****************************************************************************
* 名称：GUI_Point()
* 功能：在指定位置上画点。
* 入口参数： x		指定点所在列的位置
*           y		指定点所在行的位置
*           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
* 出口参数：返回值为1时表示操作成功，为0时表示操作失败。(操作失败原因是指定地址超出有
*          效范围)
* 说明：用户根据LCM的实际情况编写此函数。对于单色，只有一个位有效，则要使用左移的方法
*      实现point_dat = (point_dat&MASK_TAB [i]) | (color<<n)，其它位数的一样
*      处理。
****************************************************************************/
uint8  GUI_Point(uint32 x, uint32 y, TCOLOR color)
{  /* 参数过滤 */
   if(x>=GUI_LCM_XMAX) return(0);
   if(y>=GUI_LCM_YMAX) return(0);
   
   /* 设置缓冲区相应的点 */
   if( (color&0x01) != 0 ) gui_disp_buf[y][x>>3] |= DCB_HEX_TAB[x&0x07];
      else  gui_disp_buf[y][x>>3] &= (~DCB_HEX_TAB[x&0x07]);

   /* 刷新显示 */
   LCD_UpdatePoint(x, y);
   return(1);
}

/****************************************************************************
* 名称：GUI_ReadPoint()
* 功能：读取指定点的颜色。
* 入口参数：x			指定点所在列的位置
*          y		指定点所在行的位置
*          ret		保存颜色值的指针
* 出口参数：返回0时表示指定地址超出有效范围。
* 说明：对于单色，设置ret的d0位为1或0，4级灰度则为d0、d1有效，8位RGB则d0--d7有效，
*      RGB结构则R、G、B变量有效。
****************************************************************************/
int  GUI_ReadPoint(uint32 x, uint32 y, TCOLOR *ret)
{  TCOLOR  bak;

   /* 参数过滤 */
   if(x>=GUI_LCM_XMAX) return(0);
   if(y>=GUI_LCM_YMAX) return(0);
  
   /* 取得该点颜色(用户自行更改) */ 
   bak = gui_disp_buf[y][x>>3];
   if( (bak&DCB_HEX_TAB[x&0x07])!=0 ) *ret = 1;
      else  *ret = 0;
   
   return(1);
}


/****************************************************************************
* 名称：GUI_HLine()
* 功能：画水平线。
* 入口参数： x0		水平线起点所在列的位置
*           y0		水平线起点所在行的位置
*           x1      水平线终点所在列的位置
*           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
* 出口参数：无
* 说明：操作失败原因是指定地址超出缓冲区范围。
****************************************************************************/
void  GUI_HLine(uint32 x0, uint32 y0, uint32 x1, uint8 color) 
{  uint32  bak;

   if(x0>x1) 						// 对x0、x1大小进行排列，以便画图
   {  bak = x1;
      x1 = x0;
      x0 = bak;
   }
   if(x0==x1)
   {  GUI_Point(x0, y0, color);
      return;
   }
   
   do
   {  /* 设置相应的点为1 */
      if(0!=color) gui_disp_buf[y0][x0>>3] |= DCB_HEX_TAB[x0&0x07];
         else  gui_disp_buf[y0][x0>>3] &= (~DCB_HEX_TAB[x0&0x07]);
      /* 刷新显示(一次刷新一字节) */
      if( (x0&0x07)==0x07 ) LCD_UpdatePoint(x0, y0);
      
      x0++;
   }while(x1>x0);
   
   /* 对最后一点显示操作 */
   if(0!=color) gui_disp_buf[y0][x0>>3] |= DCB_HEX_TAB[x0&0x07];
      else  gui_disp_buf[y0][x0>>3] &= (~DCB_HEX_TAB[x0&0x07]);
   LCD_UpdatePoint(x0, y0);
}


/****************************************************************************
* 名称：GUI_RLine()
* 功能：画垂直线。
* 入口参数： x0		垂直线起点所在列的位置
*           y0		垂直线起点所在行的位置
*           y1      垂直线终点所在行的位置
*           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
* 出口参数：无
* 说明：操作失败原因是指定地址超出缓冲区范围。
****************************************************************************/
void  GUI_RLine(uint32 x0, uint32 y0, uint32 y1, uint8 color) 
{  uint32  bak;

   if(y0>y1) 						// 对y0、y1大小进行排列，以便画图
   {  bak = y1;
      y1 = y0;
      y0 = bak;
   }
   if(y0==y1)
   {  GUI_Point(x0, y0, color);
      return;
   }
   
   do
   {  GUI_Point(x0, y0, color);		// 逐点显示，描出垂直线
      y0++;
   }while(y1>y0);
   GUI_Point(x0, y0, color);	
}






















